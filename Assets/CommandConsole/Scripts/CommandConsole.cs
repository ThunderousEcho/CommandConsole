using System;
using System.Reflection;
using UnityEngine;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Threading;
using System.Linq;
using System.Collections.ObjectModel;

namespace CharlesOlinerCommandConsole {
    public class CommandConsole : MonoBehaviour {

        /* COMMAND CONSOLE
         * This system allows a user to enter raw C# code into their game at runtime and have it executed.
         */

        public bool fullAutocompleteLibrary; //when checked, the library is loaded with every single thing you could possibly want to type, but most of it is useless and gets in the way of the stuff you actually want. the library only updates when unloaded and reloaded.
        public bool allowAutocomplete = true; //autocomplete takes about 3 MB if in full mode. do not change the value once Start() is called.
        public bool unloadAutocompleteLibraryWhileClosed; //do not change while the console is closed.
        static Type[] autocompleteBestTypes = new Type[] {
                //feel free to add types to this list. their members will show up in autocomplete even when fullAutocompleteLibrary isn't checked.
                typeof(UnityEngine.Debug),
                typeof(GameObject),
                typeof(MonoBehaviour),
                typeof(CommandConsole), typeof(ConsoleCommand),
                typeof(Physics), typeof(RaycastHit),
                typeof(Transform),
                typeof(Vector2),  typeof(Vector3), typeof(Vector4), typeof(Quaternion), typeof(Matrix4x4),
                typeof(Shader), typeof(Material), typeof(Color)
            };
        const int maxNumAutocompleteSuggestions = 32;
        string[] autocompleteWordsArray = null;
        string[] autocompleteSuggestions = new string[maxNumAutocompleteSuggestions];
        [HideInInspector] public RectTransform autocompleteButtonPanel;
        Text[] autocompleteButtonTexts = new Text[maxNumAutocompleteSuggestions];
        [HideInInspector] public Toggle autoCompleteToggle;

        public GameObject selectedObject; //selected object

        [HideInInspector] public string temporaryFilesPath; //e.g. c:\Users\Charles\Desktop\commandStuff. Can be anywhere (except for Unity-related folders, as Unity will try to import our stuff.)
        [HideInInspector] public string pathToCscDotExeV3_5; //e.g. c:\Windows\Microsoft.NET\Framework\v3.5\csc.exe. Most computers have a copy somewhere (especially if you've installed both Unity and Visual Studio). Unity Asset Store policy prohibits me from including a copy in this package.

        [HideInInspector] public InputField inputField;
        [HideInInspector] public Text inputFieldExpansionText;

        [HideInInspector] public InputField outputField;
        [HideInInspector] public Text outputFieldExpansionText;
        string outputFieldText = "Enter a command below.";
        string outputFieldRichText = "Enter a command below.";

        [HideInInspector] public Text selectedObjectText;

        [HideInInspector] public Text toolTipExpansionText; //"expansion texts" are used to make a panel containing text fit the size of the text.
        [HideInInspector] public Text toolTipText;

        [HideInInspector] public Text autocompletePrepText;

        [HideInInspector] public Toggle showEnclosingCodeToggle;
        [HideInInspector] public Toggle enterCompilesToggle;
        [HideInInspector] public Toggle showStackTracesToggle;

        RectTransform top; //rect of most northerly element in console
        RectTransform bottom; //rect of most southerly element in console
        RectTransform console; //the entire Console's rect.

        List<string> commandHistory = new List<string>(); //list of previous commands to be revisited by the user
        int historyIndex = 0; //how far back you currently are

        ulong numGenerated = 0; //number of assemblies generated by the compiler. increments even when compilation fails.

        List<Hotkey> hotkeys = new List<Hotkey>(); //does not include things like compile and run, console scroll- jsut the hotkeys that auto-type stuff.
        [HideInInspector] public RectTransform hotkeyButtonPanel; //panel to put the hotkey buttons in
        [HideInInspector] public GameObject hotkeyButtonPrefab; //prefab for a UI button that can be pressed instead of using a hotkey. this prefab is also used as autocomplete buttons.

        [HideInInspector] public Sprite buttonSprite;
        [HideInInspector] public Sprite buttonPressedSprite;
        [HideInInspector] public Sprite buttonDisabledSprite;

        [HideInInspector] public List<Button> supressDuringCompilationButtons = new List<Button>(); //buttons to supress during compilation. other (non-button) things are also supressed during compilation

        string standardOutput; //used to collect ouput from csc.exe
        Thread compilationWaiter; //waits for compiler to finish
        Process compilation;//the external process where compilation is taking place.

        List<uint> syntaxErrorsLines = new List<uint>(); //line and column ints (32 bits) back to back as 64-bit ulongs

        int caret; //because we can't trust InputField to keep track of its caret.
        bool inputFieldSelected;

        Thread generateAutocompleteDictionaryThread;
        string title = ""; //these strings are used for indicating the progress of the dictionary generation.
        string info = "";

        struct Hotkey {
            public KeyCode key;
            public string name;
            public string code;
            public string description;
            public int cursorOffset;

            public Hotkey(KeyCode key, string name, string code, int cursorOffsetFromEnd, string description) {
                this.key = key;
                this.name = name;
                this.code = code;
                this.description = description;
                cursorOffset = code.Length + cursorOffsetFromEnd;
            }
        }

        public void CursorPositionResetHelper(bool selected) { //because we can't trust InputField to keep track of its caret when we deselect it.
            if (!selected)
                inputField.caretPosition = caret;
            inputFieldSelected = selected;
        }

        public void AbortCompilation() {
            if (compilationWaiter != null) {
                string effectiveCsOutputPath = temporaryFilesPath + "\\commandScript" + numGenerated.ToString("00000000000000000000") + ".cs";
                File.Delete(effectiveCsOutputPath);
                compilationWaiter.Abort();
                compilationWaiter = null;
                if (compilation != null) {
                    compilation.Kill();
                    addToOutput("\nCompilation aborted.");
                } else {
                    addToOutput("\nPreparation for compilation aborted.");
                }
                ProcessCommandEnd();
            } else {
                addToOutput("\nNo compilation to abort!");
            }
        }

        void OnDestroy() {

            //abort all threads
            if (compilationWaiter != null)
                compilationWaiter.Abort();
            if (compilation != null)
                compilation.Kill();
            if (generateAutocompleteDictionaryThread != null)
                generateAutocompleteDictionaryThread.Abort();

            UnityEngine.Debug.Log("All console Threads/Processes successfully aborted.");

            Application.logMessageReceived -= ProcessLog; //remove Debug.Log listener
        }

        public void p(Toggle t) { //called by toggles, changes their sprites to reflect whether they are checked.
            if (t.isOn) {
                t.GetComponent<Image>().sprite = buttonPressedSprite;
            } else {
                t.GetComponent<Image>().sprite = buttonSprite;
            }
        }

        public void OnEnable() {
            //generates the autocomplete library when the console is opened.
            if (unloadAutocompleteLibraryWhileClosed) {
                autocompletePrepText.transform.parent.gameObject.SetActive(true);
                generateAutocompleteDictionaryThread = new Thread(generateAutocompleteDictionary);
                generateAutocompleteDictionaryThread.Start();
            }
        }

        void OnDisable() {
            //drops the autocomplete library when the console is closed.
            if (unloadAutocompleteLibraryWhileClosed) {
                if (generateAutocompleteDictionaryThread != null)
                    generateAutocompleteDictionaryThread.Abort();
                autocompleteWordsArray = null;
            }
        }

        void Start() {

            commandHistory.Add("");

            //if you want to modify this script to add more hoykeys, you can add them here. Just add this one line of code below: hotkeys.Add(new Hotkey(KeyCode.<keycode>, "Name", "//code", 0));
            hotkeys.Add(new Hotkey(KeyCode.D, "Destroy", "Destroy(so);", -2, "Destroys an object at the end of the frame."));
            hotkeys.Add(new Hotkey(KeyCode.E, "Members", "members();", -2, "Lists all accessible members of an object, including functions, variables, and nested classes."));
            hotkeys.Add(new Hotkey(KeyCode.I, "Find", "so = GameObject.Find(\"\");", -3, "Finds an object from the scene."));
            hotkeys.Add(new Hotkey(KeyCode.L, "Log", "Debug.Log(\"\");", -3, "Logs a message to this console and that of the Unity editor."));
            hotkeys.Add(new Hotkey(KeyCode.M, "Message", "so.SendMessage(\"\");", -3, "Calls the function of the given name on a script connected to the target object."));
            hotkeys.Add(new Hotkey(KeyCode.R, "Relocate", "relocate(so);", -2, "Moves an object to wherever your mouse is pointing and cancels its velocity, if any."));
            hotkeys.Add(new Hotkey(KeyCode.S, "Summon", "so = summon(\"\");", -3, "Instantiates the prefab in the Resources folder with the given name wherever the mouse is pointing."));
            hotkeys.Add(new Hotkey(KeyCode.U, "Push", "push(so);", -2, "Adds a physics force to an object."));

            //instatiate buttons for hotkeys
            int index = 0;
            foreach (Hotkey key in hotkeys) {
                GameObject g = Instantiate(hotkeyButtonPrefab);
                g.transform.SetParent(hotkeyButtonPanel);
                g.name = key.name + " Button";
                Text t = g.transform.GetChild(0).GetComponent<Text>();
                t.text = key.name + " <color=grey>(Ctrl+Alt+" + key.key + ")</color>";

                EventTrigger trigger = g.GetComponent<EventTrigger>();

                EventTrigger.Entry entry = new EventTrigger.Entry();
                entry.eventID = EventTriggerType.PointerEnter;
                entry.callback.AddListener((eventData) => { string f = key.description + " <color=grey>" + key.code + "</color>"; toolTipText.text = f; });
                trigger.triggers.Add(entry);

                entry = new EventTrigger.Entry();
                entry.eventID = EventTriggerType.PointerExit;
                entry.callback.AddListener((eventData) => { toolTipText.text = ""; });
                trigger.triggers.Add(entry);

                int j = index;
                Button b = g.GetComponent<Button>();
                b.onClick.AddListener((() => { int i = j; HotkeyExecute(i); }));

                supressDuringCompilationButtons.Add(b);

                index++;
            }

            //instantiate autocomplete buttons (or destroy autocomplete-related objects, if allowAutocomplete is false)
            if (allowAutocomplete) {
                for (int i = maxNumAutocompleteSuggestions - 1; i >= 0; i--) {
                    GameObject g = Instantiate(hotkeyButtonPrefab);
                    g.transform.SetParent(autocompleteButtonPanel);
                    g.name = "Autocomplete Button " + i;
                    g.SetActive(false);

                    Text t = g.transform.GetChild(0).GetComponent<Text>();
                    t.text = "";
                    autocompleteButtonTexts[i] = t;

                    int j = i;
                    Button b = g.GetComponent<Button>();
                    b.onClick.AddListener((() => { int k = j; Autocomplete(k); }));

                    if (i == 0) {
                        EventTrigger trigger = g.AddComponent<EventTrigger>();

                        EventTrigger.Entry entry = new EventTrigger.Entry();
                        entry.eventID = EventTriggerType.PointerEnter;
                        entry.callback.AddListener((eventData) => { toolTipText.text = "(Alt)"; });
                        trigger.triggers.Add(entry);

                        entry = new EventTrigger.Entry();
                        entry.eventID = EventTriggerType.PointerExit;
                        entry.callback.AddListener((eventData) => { toolTipText.text = ""; });
                        trigger.triggers.Add(entry);
                    }
                }
            } else {
                autoCompleteToggle.interactable = false;
                autoCompleteToggle.GetComponent<Image>().sprite = buttonDisabledSprite;
                Destroy(autocompleteButtonPanel.gameObject);
                Destroy(autocompletePrepText.transform.parent.gameObject);
            }

            //add triggers to autocomplete toggle
            EventTrigger.Entry e = new EventTrigger.Entry();
            e.eventID = EventTriggerType.PointerEnter;
            if (autoCompleteToggle.interactable)
                e.callback.AddListener((eventData) => { toolTipText.text = "Autocomplete"; });
            else
                e.callback.AddListener((eventData) => { toolTipText.text = "Autocomplete (disabled in Editor)"; });
            autoCompleteToggle.GetComponent<EventTrigger>().triggers.Add(e);

            Application.logMessageReceived += ProcessLog;

            top = outputField.GetComponent<RectTransform>();
            bottom = inputField.GetComponent<RectTransform>();
            console = GetComponent<RectTransform>();

            //clear dlls from last session
            DirectoryInfo di = new DirectoryInfo(temporaryFilesPath);
            foreach (FileInfo file in di.GetFiles()) {
                if (file.Name.StartsWith("commandLibrary") && file.Name.EndsWith(".dll")) {
                    file.Delete();
                }
            }
        }

        public static void TypeEnumerate(ref HashSet<string> autocompleteWords, Type[] types) {
            foreach (Type type in types) {
                if (type.IsNotPublic) continue;
                autocompleteWords.Add(type.Name);
                MemberInfo[] members = type.GetMembers();
                foreach (MemberInfo member in members) {
                    switch (member.MemberType) {
                        case MemberTypes.Constructor:
                            ConstructorInfo c = (ConstructorInfo)member;
                            if (c.IsPrivate) continue;
                            break;
                        case MemberTypes.Custom: break; //no way to check whether acessible
                        case MemberTypes.Event:
                            EventInfo e = (EventInfo)member;
                            if (e.GetAddMethod().IsPrivate) {
                                if (!e.GetRaiseMethod().IsPrivate) {
                                    if (!e.GetRemoveMethod().IsPrivate) {
                                        if (e.GetOtherMethods(false).Length == 0) continue;
                                    }
                                }
                            }
                            break;
                        case MemberTypes.Field:
                            FieldInfo f = (FieldInfo)member;
                            if (f.IsPrivate) continue;
                            break;
                        case MemberTypes.Method:
                            MethodInfo m = (MethodInfo)member;
                            if (m.IsSpecialName) {
                                if (m.Name.StartsWith("set_")) continue; //removes set accessors (which cannot be invoked directly)
                                if (m.Name.StartsWith("get_")) continue; //removes get accessors (which cannot be invoked directly)
                            }
                            if (m.IsPrivate) continue;
                            break;
                        case MemberTypes.NestedType: //can't figure out how to check this for publicness. but it might be included in Assembly.GetTypes();
                            break;
                        case MemberTypes.Property:
                            PropertyInfo p = (PropertyInfo)member;
                            if (p.GetAccessors(false).Length == 0) continue;
                            break;
                        case MemberTypes.TypeInfo: //can't figure out how to check this for publicness either. but it too might be included in Assembly.GetTypes();
                            break;
                    }
                    autocompleteWords.Add(member.Name);
                }
            }
        }

        void generateAutocompleteDictionary() {

            title = "...Fetching words...";

            HashSet<string> autocompleteWords = new HashSet<string>();

            if (fullAutocompleteLibrary) {
                //use reflection to get every assembly, type, and member in the domain and add their names to autocompleteWords
                foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies()) {
                    Type[] types = null;
                    try { types = assembly.GetExportedTypes(); } catch (ReflectionTypeLoadException e) { types = e.Types; } //get only acessible types
                    if (types == null)
                        continue;
                    info = assembly.GetName().Name;
                    TypeEnumerate(ref autocompleteWords, types);
                    autocompleteWords.Add(assembly.GetName().Name);
                }
            } else {
                TypeEnumerate(ref autocompleteWords, autocompleteBestTypes);
            }

            info = string.Format("Words in autocomplete: " + autocompleteWords.Count);
            title = "...Querying...";
            IEnumerable<string> query = autocompleteWords.OrderBy(aaaaa => aaaaa);
            title = "...Casting to array...";
            autocompleteWordsArray = query.ToArray();
            title = "Autocomplete ready.";
        }

        public void Opacity(Slider slider) { //changes opcaity of background
            GetComponent<Image>().color = new Color(0, 0, 0, slider.value);
        }

        public void HotkeyExecute(int index) { //for just the auto-type hotkeys
            Hotkey key = hotkeys[index];
            inputField.text = inputField.text.Insert(inputField.caretPosition, key.code);
            inputField.caretPosition += key.cursorOffset;
        }

        public void Autocomplete(int i) { //actually types the suggestion into the input field.
            if (i < maxNumAutocompleteSuggestions) {
                string word = autocompleteSuggestions[i];

                for (int g = caret - 1; g >= 0; g--) {
                    if (g > inputField.text.Length - 1) {
                        g = inputField.text.Length - 1;
                        if (g < 0)
                            break;
                    }
                    char c = inputField.text[g];
                    if (!char.IsLetterOrDigit(c))
                        break;
                    inputField.text = inputField.text.Remove(g, 1);
                    caret--;
                }

                if (caret > inputField.text.Length)
                    caret = inputField.text.Length;
                else if (caret < 0)
                    caret = 0;

                inputField.text = inputField.text.Insert(caret, word);
                caret += word.Length;
                inputField.caretPosition = caret;

                for (int q = 0; q < maxNumAutocompleteSuggestions; q++) {
                    autocompleteButtonTexts[q].text = "";
                    autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(false);
                }
            }
        }

        public void Clear() { //clears the console.
            outputFieldExpansionText.text = outputFieldRichText = "Console cleared.";
            outputField.text = outputFieldText = "Console cleared.";
        }

        void ProcessLog(string logString, string stackTrace, LogType type) {

            //intercepts logs from unity's debug system and prints them out with different colors.

            string color = "#0000ff";
            string color2 = "#000080";
            switch (type) {
                case LogType.Assert:
                    color = "#00ffff";
                    color2 = "#008080";
                    break;
                case LogType.Error:
                    color = "#ff0000";
                    color2 = "#800000";
                    break;
                case LogType.Exception:
                    color = "#ff8000";
                    color2 = "#804000";
                    break;
                case LogType.Log:
                    color = "#00ffff";
                    color2 = "#008080";
                    break;
                case LogType.Warning:
                    color = "#ffff00";
                    color2 = "#808000";
                    break;
            }

            if (showStackTracesToggle.isOn) {
                addToOutput("\n" + logString.Trim() + "\n" + stackTrace.Trim(),
                            "\n<color=" + color + ">" + logString.Trim() + "</color>\n<color=" + color2 + ">" + stackTrace.Trim() + "</color>");
            } else {
                addToOutput("\n" + logString.Trim(),
                                    "\n<color=" + color + ">" + logString.Trim() + "</color>");
            }
        }

        public void toggleShowEnclosingCode() {
            string before = generateEnclosingCode(true);
            string after = generateEnclosingCode(false);
            if (showEnclosingCodeToggle.isOn) {
                inputField.text = before + inputField.text + after;
                inputField.caretPosition += before.Length;
            } else {
                bool b = inputField.text.StartsWith(before);
                bool a = inputField.text.EndsWith(after);
                if (b && a) {
                    inputField.text = inputField.text.Substring(before.Length, inputField.text.Length - (before.Length + after.Length));
                } else {
                    inputField.text = "";
                }
            }
        }

        public void UpdateInputText() { //called whenever the inputfield's text changes.
            UpdateAutocompleteSuggestions();

            //all this stuff turns the lines with syntax errors in them purple.
            if (syntaxErrorsLines.Count > 0) {
                string[] lines = inputField.text.Split(new[] { '\n' }, StringSplitOptions.None);
                for (int i = syntaxErrorsLines.Count - 1; i >= 0; i--) {
                    uint errorLine = syntaxErrorsLines[i];
                    if (errorLine > lines.Length - 1) continue;
                    string line = lines[errorLine];
                    line = "<color=#ff00a0>" + line + "</color>";
                    lines[errorLine] = line;
                }
                inputFieldExpansionText.text = string.Join("\n", lines);
            } else {
                inputFieldExpansionText.text = inputField.text;
            }
        }

        public void UpdateAutocompleteSuggestions() {

            if (!allowAutocomplete)
                return;

            if (generateAutocompleteDictionaryThread == null && autoCompleteToggle.isOn) { //autocomplete is ready
                string f = "";
                for (int j = 0; j < maxNumAutocompleteSuggestions; j++)
                    autocompleteSuggestions[j] = null;
                if (inputField.text.Length > 0) {
                    for (int i = caret - 1; i >= 0; i--) {
                        if (i > inputField.text.Length - 1)
                            i = inputField.text.Length - 1;
                        char c = inputField.text[i];
                        if (!char.IsLetter(c))
                            break;
                        f = c + f;
                    }
                    if (f.Length > 0) {
                        int start = Array.BinarySearch(autocompleteWordsArray, f.ToLower());
                        if (start < 0) start = ~start;
                        int m = 0;
                        for (int i = start; i < autocompleteWordsArray.Length; i++) {

                            string word = autocompleteWordsArray[i];

                            if (!word.ToLower().StartsWith(f.ToLower()))
                                break;
                            if (word.Equals(f))
                                continue;

                            autocompleteSuggestions[m] = word;
                            m++;
                            if (m >= maxNumAutocompleteSuggestions)
                                break;
                        }
                    }
                }

                for (int q = 0; q < maxNumAutocompleteSuggestions; q++) {
                    if (autocompleteSuggestions[q] != null) {

                        if (q == 0)
                            autocompleteButtonTexts[q].text = "<color=#008000>" + autocompleteSuggestions[q].Insert(f.Length, "</color><color=#00ff00>") + "</color>";
                        else
                            autocompleteButtonTexts[q].text = "<color=grey>" + autocompleteSuggestions[q].Insert(f.Length, "</color>");

                        autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(true);
                    } else {
                        autocompleteButtonTexts[q].text = "";
                        autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(false);
                    }
                }
            } else {
                for (int q = 0; q < maxNumAutocompleteSuggestions; q++) {
                    autocompleteButtonTexts[q].text = "";
                    autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(false);
                }
            }
        }

        public void Update() {

            //displays the status of the autocomplete library generation and helps transition out of it when it ends.
            if (generateAutocompleteDictionaryThread != null) {
                autocompletePrepText.text = title + "\n" + info;
                if (!generateAutocompleteDictionaryThread.IsAlive) {
                    generateAutocompleteDictionaryThread = null;
                    autocompletePrepText.transform.parent.gameObject.SetActive(false);
                }
            }

            //because inputfields are weird
            if (inputFieldSelected) {
                if (caret != inputField.caretPosition) {
                    caret = inputField.caretPosition;
                    UpdateAutocompleteSuggestions();
                }
            }

            //handles transition from middle to end of command processing
            if (compilationWaiter != null && !compilationWaiter.IsAlive) {
                compilationWaiter = null;
                ProcessCommandEnd();
            }

            //command history r/w
            if (historyIndex == commandHistory.Count - 1) {
                commandHistory[historyIndex] = inputField.text;
            } else {
                if (inputField.text != commandHistory[historyIndex]) {
                    historyIndex = commandHistory.Count - 1;
                }
            }

            //makes the tooltip go between the mouse and the screen edge
            Vector2 a = Camera.main.ScreenToViewportPoint(Input.mousePosition);
            a.x = Mathf.Round(a.x);
            if (a.y < 0.5)
                a.y = -1;
            else
                a.y = 2;
            toolTipExpansionText.rectTransform.pivot = a;

            //controls height of console element to fit children for proper scrolling
            Vector3[] corners = new Vector3[4];
            top.GetComponent<RectTransform>().GetWorldCorners(corners);
            float topHeight = corners[2].y;
            bottom.GetComponent<RectTransform>().GetWorldCorners(corners);
            float bottomHeight = corners[0].y;
            Vector2 sd = console.sizeDelta;
            sd.y = 20 + topHeight - bottomHeight; //20 is a margin
            console.sizeDelta = sd;

            //selected object indicator
            if (selectedObject != null)
                selectedObjectText.text = "Use <b><color=#00ff00>so</color></b> as a variable in your commands to reference <b><color=#00ff00>" + selectedObject + "</color></b>. For example, <i>MonoBehaviour.Destroy(so);</i>.";
            else
                selectedObjectText.text = "Right click an object to select it.";

            //object selector
            if (Input.GetMouseButtonDown(1) && !inputField.isFocused) {
                RaycastHit h;
                if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out h)) {
                    selectedObject = h.collider.gameObject;
                } else {
                    selectedObject = null;
                }
            }

            //trigegr command processing
            if (Input.GetKeyDown(KeyCode.Return) && enterCompilesToggle.isOn) {
                ProcessCommandBeginning();
            }
            if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) {
                if (Input.GetKeyDown(KeyCode.LeftShift) || Input.GetKeyDown(KeyCode.RightShift)) {
                    ProcessCommandBeginning();
                }
            }

            if (inputField.interactable) { //if not compiling
                                           //auto-type hotkeys
                if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) {
                    if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt) || Input.GetKey(KeyCode.AltGr)) {
                        foreach (Hotkey key in hotkeys) {
                            if (Input.GetKeyDown(key.key)) {
                                inputField.text = inputField.text.Insert(inputField.caretPosition, key.code);
                                inputField.caretPosition += key.cursorOffset;
                            }
                        }
                    }
                }
                //command history scrolling
                if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) {
                    if (Input.GetKeyDown(KeyCode.UpArrow)) {
                        scrollCommandHistory(true);
                    }
                    if (Input.GetKeyDown(KeyCode.DownArrow)) {
                        scrollCommandHistory(false);
                    }
                }
                //autocomplete
                if (!Input.GetKey(KeyCode.LeftControl) && !Input.GetKey(KeyCode.RightControl)) {
                    if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt) || Input.GetKey(KeyCode.AltGr)) {
                        Autocomplete(0);
                    }
                }
            }
        }

        public void scrollCommandHistory(bool direction) { //true is up
            if (direction && historyIndex > 0) {
                historyIndex--;
                inputField.text = commandHistory[historyIndex];
            } else if (!direction && historyIndex < commandHistory.Count - 1) {
                historyIndex++;
                inputField.text = commandHistory[historyIndex];
            }
        }

        public void LateUpdate() {
            //makes the tooltip follow thw mouse cursor
            toolTipExpansionText.transform.position = Input.mousePosition;
            toolTipExpansionText.text = toolTipText.text;
            toolTipExpansionText.gameObject.SetActive(toolTipText.text != "");
        }

        public string generateEnclosingCode(bool before) {//this code is placed before and after the user-inputted command to appease the compiler gods.
            if (before) {
                return
                "using UnityEngine;" + '\n' +
                "using System;" + '\n' +
                "using CharlesOlinerCommandConsole;" + '\n' +
                "public class ConsoleCommand" + numGenerated.ToString("00000000000000000000") + ": ConsoleCommand{" + '\n' +
                    "\tpublic static object Entry(CommandConsole c) { return Command(ref c.selectedObject); }" + '\n' +
                    "\tpublic static object Command(ref GameObject so) {" + '\n' +
                        "\t\t";
            } else {
                return
                                             '\n' +
                        "\t\treturn \"\";" + '\n' +
                    "\t}" + '\n' +
                "}";
            }
        }
        //if the enclosing code changes, these values too must be changed
        int lineOffset = 5; //number of lines in the before part of the enclosing code
        int columnOffset = 2; //number of characters to the left of the user command

        public void ProcessCommandBeginning() {

            if (!inputField.interactable) //if already compiling, don't compile more
                return;

            inputField.text = inputField.text.Trim();
            inputField.text = inputField.text.Replace("\r", ""); //Unity is always \n
            if (inputField.text == "")
                return;

            //command history stuff
            commandHistory[commandHistory.Count - 1] = inputField.text;
            commandHistory.Add("");
            historyIndex = commandHistory.Count - 1;

            //make buttons that would otherwise break the system non-interactible.
            inputField.interactable = false;
            foreach (Button b in supressDuringCompilationButtons) {
                b.interactable = false;
            }
            showEnclosingCodeToggle.interactable = false;
            showEnclosingCodeToggle.GetComponent<Image>().sprite = buttonDisabledSprite;

            //start next part of compilation
            compilationWaiter = new Thread(ProcessCommandMiddle);
            compilationWaiter.Start();
        }

        void ProcessCommandMiddle() {
            string effectiveDllInputPath = temporaryFilesPath + "\\commandLibrary" + numGenerated.ToString("00000000000000000000") + ".dll";
            string effectiveCsOutputPath = temporaryFilesPath + "\\commandScript" + numGenerated.ToString("00000000000000000000") + ".cs";

            string code = inputField.text;

            if (!showEnclosingCodeToggle.isOn) {
                code = generateEnclosingCode(true) + code + generateEnclosingCode(false);
            }

            File.WriteAllText(effectiveCsOutputPath, code); //write the cs code to a file

            //prepare command to be executed
            string args = "";
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly a in assemblies) {

                switch (a.GetName().Name) { //things that csc.exe already includes by default
                    case "System.Xml": continue;
                    case "System.Xml.Linq": continue;
                    case "System.Configuration": continue;
                    case "System": continue;
                    case "System.Core": continue;
                    case "mscorlib": continue;
                    case "UnityEditor.Purchasing": continue; //this one isn't a default include, but it might be a security issue to allow commands to use it.
                }
                args += "/reference:\"" + a.CodeBase.Substring(8) + "\" "; //substring removes file:/// from the front of it
            }
            args += "/target:library /optimize /out:\"" + effectiveDllInputPath + "\" \"" + effectiveCsOutputPath + "\"";

            //prepare compiler process
            Process p = new Process();
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.FileName = pathToCscDotExeV3_5;
            p.StartInfo.Arguments = args;
            p.Start();
            compilation = p;

            for (int i = 0; i < 4; i++) {
                p.StandardOutput.ReadLine(); //get rid of first 4 lines of output (version numbers and stuff)
            }

            syntaxErrorsLines.Clear();

            //process sytntax errors
            standardOutput = "";
            while (!p.StandardOutput.EndOfStream) {

                string f = p.StandardOutput.ReadLine().Replace(effectiveCsOutputPath, "");

                if (!f.StartsWith("(")) {
                    standardOutput += "\n" + f;
                    continue;
                }

                f = f.Remove(0, 1); //remove start parentheses

                int line = 0;
                int column = 0;
                int sLength = 0;

                try {
                    string s = f.Substring(0, f.IndexOf(')'));
                    string[] n = s.Split(',');
                    sLength = s.Length + 1;

                    line = int.Parse(n[0]);
                    column = int.Parse(n[1]);
                } catch (Exception) {
                    standardOutput += "\n(" + f;
                    continue;
                }

                line -= 1;
                if (!showEnclosingCodeToggle.isOn) {
                    line -= lineOffset;
                    column -= columnOffset;
                }

                f = f.Substring(sLength, f.Length - sLength);

                if (line > 0)
                    syntaxErrorsLines.Add((uint)line);

                standardOutput += "\nSyntax error at Line " + line + ", Column " + column + f;
            }
            standardOutput += p.StandardOutput.ReadToEnd();

            p.WaitForExit();
            compilation = null;
        }

        void ProcessCommandEnd() {
            compilation = null; //in case of abort

            string effectiveDllInputPath = temporaryFilesPath + "\\commandLibrary" + numGenerated.ToString("00000000000000000000") + ".dll";
            string effectiveCsOutputPath = temporaryFilesPath + "\\commandScript" + numGenerated.ToString("00000000000000000000") + ".cs";

            addToOutput("\n" + inputField.text, "\n<color=#00a000>" + inputField.text + "</color>");

            File.Delete(effectiveCsOutputPath); //don't need it anymore, it would just be taking up space otherwise.
            if (!File.Exists(effectiveDllInputPath)) {
                //output syntax errors
                addToOutput("\n" + standardOutput.Trim(), "\n<color=#ff00a0>" + standardOutput.Trim() + "</color>");
                numGenerated++;
            } else {
                //load back compiled code
                var assembly = Assembly.LoadFile(effectiveDllInputPath);
                Type[] types = assembly.GetTypes();
                foreach (Type type in types) {
                    MethodInfo[] methods = type.GetMethods();
                    foreach (MethodInfo method in methods) {
                        if (method.IsStatic && method.Name == "Entry") {
                            object o = null;
                            try {
                                o = method.Invoke(null, new object[] { this });
                            } catch (Exception e) {
                                UnityEngine.Debug.LogException(e);
                            }
                            if (o != null) {
                                if (o.ToString() != "") {
                                    addToOutput("\n" + o.ToString(), "\n<color=#00ff00>" + o.ToString() + "</color>");
                                }
                            } else {
                                addToOutput("\nnull", "\n<color=#00ff00>null</color>");
                            }
                        }
                    }
                }
                numGenerated++;
                if (showEnclosingCodeToggle.isOn)
                    inputField.text = generateEnclosingCode(true) + generateEnclosingCode(false);
                else
                    inputField.text = "";
            }

            //re-enable elements disabled earlier.
            inputField.interactable = true;
            foreach (Button b in supressDuringCompilationButtons) {
                b.interactable = true;
            }
            showEnclosingCodeToggle.interactable = true;
            p(showEnclosingCodeToggle);

            UpdateInputText();
        }

        void addToOutput(string msg, string richMsg = null) { //logs a message to the outputfield.

            //two strings are required because inputfields don't support rich text.
            //this system layers a rich textbox over an invisible inputfield textbox.
            //we only need the inputfield textbox for copy-pasting.

            if (richMsg == null)
                richMsg = msg;

            outputFieldText += msg;
            outputFieldRichText += richMsg;

            outputField.text = outputFieldText;
            outputFieldExpansionText.text = outputFieldRichText;
        }
    }
}